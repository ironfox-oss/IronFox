From 7f1c1b564bd365adfd92cb43f2c2bd3f650b5957 Mon Sep 17 00:00:00 2001
From: celenity <celenity@celenity.dev>
Date: Tue, 10 Feb 2026 17:31:22 +0000
Subject: [PATCH] fix: Ensure Canvas Randomization is properly applied

Adapted from any1here's LibreWolf patch: https://codeberg.org/librewolf/source/src/commit/343645241e58cb43b713968cb29614688e6d8979/patches/fpp-canvas-fix.patch

Signed-off-by: celenity <celenity@celenity.dev>
---
 dom/canvas/CanvasRenderingContext2D.cpp                  | 6 +++---
 dom/canvas/ClientWebGLContext.cpp                        | 6 +++---
 toolkit/components/resistfingerprinting/nsRFPService.cpp | 4 ++--
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/dom/canvas/CanvasRenderingContext2D.cpp b/dom/canvas/CanvasRenderingContext2D.cpp
index 16eb6f61903a..321538d5eb71 100644
--- a/dom/canvas/CanvasRenderingContext2D.cpp
+++ b/dom/canvas/CanvasRenderingContext2D.cpp
@@ -2284,7 +2284,7 @@ UniquePtr<uint8_t[]> CanvasRenderingContext2D::GetImageBuffer(
         PrincipalOrNull(), ret.get(), out_imageSize->width,
         out_imageSize->height,
         out_imageSize->width * out_imageSize->height * 4);
-    if (aExtractionBehavior == CanvasUtils::ImageExtraction::Randomize) {
+    if (aExtractionBehavior == CanvasUtils::ImageExtraction::Randomize || aExtractionBehavior == CanvasUtils::ImageExtraction::EfficientRandomize) {
       nsRFPService::RandomizePixels(
           GetCookieJarSettings(), PrincipalOrNull(), ret.get(),
           out_imageSize->width, out_imageSize->height,
@@ -6611,7 +6611,7 @@ nsresult CanvasRenderingContext2D::GetImageDataArray(
   //
   // Note that we don't need to clone if we will use the place holder because
   // the place holder doesn't use actual image data.
-  if (extractionBehavior == CanvasUtils::ImageExtraction::Randomize) {
+  if (extractionBehavior == CanvasUtils::ImageExtraction::Randomize || extractionBehavior == CanvasUtils::ImageExtraction::EfficientRandomize) {
     if (readback) {
       readback = CreateDataSourceSurfaceByCloning(readback);
     }
@@ -6633,7 +6633,7 @@ nsresult CanvasRenderingContext2D::GetImageDataArray(
       // service) after we call JS_GetUint8ClampedArrayData, we will
       // pre-generate the randomness required for GeneratePlaceholderCanvasData.
       randomData = TryToGenerateRandomDataForPlaceholderCanvasData();
-    } else if (extractionBehavior == CanvasUtils::ImageExtraction::Randomize) {
+    } else if (extractionBehavior == CanvasUtils::ImageExtraction::Randomize || extractionBehavior == CanvasUtils::ImageExtraction::EfficientRandomize) {
       // Apply the random noises if canvan randomization is enabled. We don't
       // need to calculate random noises if we are going to use the place
       // holder.
diff --git a/dom/canvas/ClientWebGLContext.cpp b/dom/canvas/ClientWebGLContext.cpp
index 12492d606cc2..d16ecc6be00b 100644
--- a/dom/canvas/ClientWebGLContext.cpp
+++ b/dom/canvas/ClientWebGLContext.cpp
@@ -1362,7 +1362,7 @@ UniquePtr<uint8_t[]> ClientWebGLContext::GetImageBuffer(
   *out_imageSize = dataSurface->GetSize();
 
   nsRFPService::PotentiallyDumpImage(PrincipalOrNull(), dataSurface);
-  if (aExtractionBehavior == CanvasUtils::ImageExtraction::Randomize) {
+  if (aExtractionBehavior == CanvasUtils::ImageExtraction::Randomize || aExtractionBehavior == CanvasUtils::ImageExtraction::EfficientRandomize) {
     return gfxUtils::GetImageBufferWithRandomNoise(
         dataSurface, premultAlpha, GetCookieJarSettings(), PrincipalOrNull(),
         out_format);
@@ -3632,7 +3632,7 @@ void ClientWebGLContext::GetBufferSubData(GLenum target, GLintptr srcByteOffset,
       if (extraction == CanvasUtils::ImageExtraction::Placeholder) {
         dom::GeneratePlaceholderCanvasData(destView->size_bytes(),
                                            destView->Elements());
-      } else if (extraction == CanvasUtils::ImageExtraction::Randomize) {
+      } else if (extraction == CanvasUtils::ImageExtraction::Randomize || extraction == CanvasUtils::ImageExtraction::EfficientRandomize) {
         // We have no idea what's in the buffer. So, we randomize it as if each
         // elemSize bytes is a single element.
         uint8_t elementsPerGroup = 1,
@@ -5391,7 +5391,7 @@ void ClientWebGLContext::ReadPixels(GLint x, GLint y, GLsizei width,
       } else {
         RecordCanvasUsage(CanvasExtractionAPI::ReadPixels,
                           CSSIntSize(width, height));
-        if (extraction == CanvasUtils::ImageExtraction::Randomize) {
+        if (extraction == CanvasUtils::ImageExtraction::Randomize || extraction == CanvasUtils::ImageExtraction::EfficientRandomize) {
           const auto pii = webgl::PackingInfoInfo::For(desc.pi);
           // DoReadPixels() requres pii to be Some().
           MOZ_ASSERT(pii.isSome());
diff --git a/toolkit/components/resistfingerprinting/nsRFPService.cpp b/toolkit/components/resistfingerprinting/nsRFPService.cpp
index d900f49a3b1b..c81d308cb823 100644
--- a/toolkit/components/resistfingerprinting/nsRFPService.cpp
+++ b/toolkit/components/resistfingerprinting/nsRFPService.cpp
@@ -1886,7 +1886,7 @@ nsresult nsRFPService::RandomizeElements(
   }
 
   // Don't randomize if all groups are uniform.
-  const bool allGroupsMatch = [&]() {
+/*  const bool allGroupsMatch = [&]() {
     auto itr = RangedPtr<const uint8_t>(aData, aSizeInBytes);
     const auto itrEnd = itr + (groupCount * groupSize);
     for (; itr != itrEnd; itr += groupSize) {
@@ -1898,7 +1898,7 @@ nsresult nsRFPService::RandomizeElements(
   }();
   if (allGroupsMatch) {
     return NS_OK;
-  }
+  } */
 
   auto timerId =
       glean::fingerprinting_protection::canvas_noise_calculate_time_2.Start();
-- 
2.53.0

